#!/usr/bin/env python3

import sys, getopt

# startx, endx, starty, endy
dim = []

# constants used in converting part sizes
minx = 0
maxx = 534
halfx1 = maxx / 2
halfx2 = halfx1 + 1
miny = 0
maxy = 782
halfy1 = maxy / 2
halfy2 = halfy1 + 1

def opterr(err):
    sys.stderr.write("Error: " + err + "\n")
    sys.stderr.write("Call pcb-psinvert with -h to see help\n")
    exit(2)

try:
    opts, args = getopt.getopt(sys.argv[1:], "hp:")
except getopt.GetoptError as err:
    opterr(str(err))

for o, a in opts:
    if o == "-h":
        help = ''
        help += "This script can be used to invert PostScript files generated by TraxPlot\n"
        help += "to be used with negative photopolymer films to etch PCBs.\n"
        help += "\n"
        help += "Usage: pcb-psinvert -p <part> < <input file> > <output file>\n"
        help += "\n"
        help += "Parts to invert:\n"
        help += "  f: full image\n"
        help += "  l: left half\n"
        help += "  r: right half\n"
        help += "  t: top half\n"
        help += "  b: bottom half\n"
        help += "  tl or lt: top left quarter\n"
        help += "  tr or rt: top right quarter\n"
        help += "  bl or lb: bottom left quarter\n"
        help += "  br or rb: bottom right quarter\n"
        sys.stderr.write(help)
        exit(1)
    elif o == "-p":
        if a == "f":
            dim = [ minx, maxx, miny, maxy ]
        elif a == "l":
            dim = [ minx, halfx1, miny, maxy ]
        elif a == "r":
            dim = [ halfx2, maxx, miny, maxy ]
        elif a == "t":
            dim = [ minx, maxx, halfy2, maxy ]
        elif a == "b":
            dim = [ minx, maxx, miny, halfy1 ]
        elif a == "tl" or a == "lt":
            dim = [ minx, halfx1, halfy2, maxy ]
        elif a == "tr" or a == "rt":
            dim = [ halfx2, maxx, halfy2, maxy ]
        elif a == "bl" or a == "lb":
            dim = [ minx, halfx1, miny, halfy1 ]
        elif a == "br" or a == "rb":
            dim = [ halfx2, maxx, miny, halfy1 ]
        else:
            opterr("invalid part given")
    else:
        opterr("invalid option given")

if not dim:
    opterr("missing mandatory -p switch")

for line in sys.stdin:
    line = line.replace("\r\n", "")
    output = line + "\r\n"
    if line.endswith(" translate"):
        if line != "30.24 28.80 translate":
            sys.stderr.write("Warning: unknown translation (" + line + "), results might be incorrect")

        # after translation has been set, we define a rectangle and fill it
        # rectangle is defined in units 1/72 of an inch

        sx = str(dim[0])
        ex = str(dim[1])
        sy = str(dim[2])
        ey = str(dim[3])

        # first, we define new path with this rectangle
        output += "newpath\r\n"
        output += sx + " " + sy + " moveto\r\n"
        output += ex + " " + sy + " lineto\r\n"
        output += ex + " " + ey + " lineto\r\n"
        output += sx + " " + ey + " lineto\r\n"
        output += sx + " " + sy + " lineto\r\n"
        output += "closepath\r\n"

        # then, we fill this rectangle black
        output += "0.00 setgray\r\n"
        output += "fill\r\n"
    elif line.find("setgray") != -1:
        # setgray occurs only in the prologue
        #
        # we replace all instances of setgray with pop 1.00 setgray,
        # this way we will pop the original gray value from the stack
        # and substitute 1.00 instead
        output = output.replace("setgray", "pop 1.00 setgray")
    elif line[:4] == "/DH ":
        # we have to redefine a hole (DH) as it puts 1 (white) on the stack
        # and calls SC to draw a filled circle. we need it to be black (0),
        # but we just modified SC to ignore the setgray setting. we'll create
        # a new SC, called SC2, that won't ignore it, and define DH to call it
        # instead
        output = "/SC2 {newpath 1 setlinewidth setgray 0 360 arc fill} bind def\r\n"
        output += "/DH {HS 0 ne {HS 0 SC2} {pop pop} ifelse} bind def\r\n"

    sys.stdout.write(output)
